mod consumer;
mod producer;

mod messages {

    use crate::blockchain::{
        property::*,
        protocols::{InputBlockHash, InputBlockHeader, RankingBlockHash},
    };

    /// Ask the producer to find the newest point that exists on its blockchain.
    pub struct FindIntersect<E: Era>(pub Vec<RankingBlockHash<E>>);

    /// Tell the consumer about the first point that can be found on the producer's chain.
    /// They can start consuming from here, or try to find further points.
    /// The intersect found will become the read pointer for the consumer, so following
    /// up with a `RequestNext` message will go from here. But the consumer can also
    /// send further `FindIntersect` messages, bisecting until the best possible match
    /// is found; the better results will adjust the read pointer.
    pub struct IntersectFound<E: Era>(pub RankingBlockHash<E>);

    /// Tell the consumer that none of the identifiers in `FindIntersect` are known.
    pub struct IntersectNotFound;

    /// Ask the producer to send the next ranking block.
    pub struct RequestNext;

    /// Tell the consumer that they are caught up with the chain, and the next even is going
    /// to arrive when the producer's chain changes.
    pub struct AwaitReply;

    /// Tell the consumer to extend its chain with the next connecting ranking block.
    /// The ranking block is small, it could be the header of a traditional block,
    /// or a dedicated block type.
    pub struct RollForward<E: Era>(pub E::RankingBlock<'static>);

    /// Tell the consumer to an earlier block hash.
    pub struct RollBackward<E: Era>(pub RankingBlockHash<E>);

    /// Ask the producer to send a list of missing input block headers.
    /// The consumer should only ask for inputs that they don't have after
    /// being given a new ranking block with `RollForward`. The producer
    /// can work out which input blocks fall in the range between the latest
    /// ranking block it sent the consumer and the one before that, so it
    /// can detect if the consumer is asking for things that are unreasonable.
    ///
    /// The inputs are assumed to be generated by PoW for example, so they
    /// would be a very expensive form to flood a peer with useless data.
    ///
    /// It is assumed that there is a separate protocol for announcing input
    /// blocks, so the next leader can put them into ranking blocks, and this
    /// is not part of this protocol. Here we just fill in any missing bits.
    /// Another motivation to do this was that the Rust Analyzer was unable
    /// to deal with the complexity of the `Next` protocol if notifications
    /// were included.
    pub struct RequestInputs<E: Era>(pub Vec<InputBlockHash<E>>);

    /// The producer responds to the consumer with the missing inputs block headers.
    /// The response contains the headers for the hashes the consumer asked for in
    /// the preceding `RequestInputs`. Since the producer earlier sent a ranking block
    /// that referenced these, it must have all the inputs as well, so the number of
    /// items must be exactly the same.
    pub struct ReplyInputs<E: Era>(pub Vec<InputBlockHeader<E>>);

    /// Terminate the protocol.
    pub struct Done;
}

/// Sync protocols described from the server's perspective.
mod protocol {
    use super::messages::*;
    use crate::blockchain::property::Era;
    use crate::session_types::*;

    /// Protocol to find the latest block that intersects in the chains of the client and the server.
    pub type Intersect<E: Era> = Recv<
        FindIntersect<E>,
        Choose<Send<IntersectFound<E>, Var<Z>>, Send<IntersectNotFound, Var<Z>>>,
    >;

    /// Respond to the consumer with the next available ranking block, or a rollback to an earlier one.
    pub type Roll<E: Era> = Choose<Send<RollForward<E>, Var<Z>>, Send<RollBackward<E>, Var<Z>>>;

    /// Protocol to request the next available ranking block or input block header
    pub type Next<E: Era> = Recv<RequestNext, Choose<Roll<E>, Send<AwaitReply, Roll<E>>>>;

    /// Protocol to request missing input block headers.
    pub type Missing<E: Era> = Recv<RequestInputs<E>, Send<ReplyInputs<E>, Var<Z>>>;

    /// Receive a quit request to quit from the client.
    pub type Quit = Recv<Done, Eps>;

    // NOTE: Not surrounding with `Rec` because we will use a single `.enter()` and never retrun to the base.
    pub type Server<E: Era> = Offer<Intersect<E>, Offer<Next<E>, Offer<Missing<E>, Quit>>>;

    // NOTE: Unfortunately the protocol is too complex and the Rust Analyzer just says `{unknown}`
    // for the variables with type `Client`. One workaround is to pass it to subroutines which
    // have simpler protocols.
    pub type Client<E: Era> = <Server<E> as HasDual>::Dual;
}

#[cfg(test)]
mod test {
    use std::thread;

    use crate::{blockchain::eras::CoEra, session_types::session_channel};

    use super::{consumer::Consumer, messages::Done, producer::Producer};

    #[test]
    fn chain_sync() {
        let producer = Producer::<CoEra>::new();
        let consumer = Consumer::<CoEra>::new();

        let (server_chan, client_chan) = session_channel();

        let srv_t = thread::spawn(move || producer.sync_chain(server_chan));

        client_chan
            .enter()
            .sel2()
            .sel2()
            .sel2()
            .send(Done)
            .unwrap()
            .close()
            .unwrap();

        srv_t.join().unwrap().unwrap();
    }
}
