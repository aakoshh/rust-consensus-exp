mod messages {
    use crate::blockchain::property::*;

    type RankingBlockHash<E: Era> = <E::RankingBlock<'static> as HasHash<'static>>::Hash;
    type InputBlockHash<E: Era> = <E::InputBlock<'static> as HasHash<'static>>::Hash;
    type InputBlockHeader<E: Era> = <E::InputBlock<'static> as HasHeader>::Header;

    /// Ask the producer to find the newest point that exists on its blockchain.
    pub struct FindIntersect<E: Era>(Vec<RankingBlockHash<E>>);

    /// Tell the consumer about the first point that can be found on the producer's chain.
    /// They can start consuming from here, or try to find further points.
    /// The intersect found will become the read pointer for the consumer, so following
    /// up with a `RequestNext` message will go from here. But the consumer can also
    /// send further `FindIntersect` messages, bisecting until the best possible match
    /// is found; the better results will adjust the read pointer.
    pub struct IntersectFound<E: Era>(RankingBlockHash<E>);

    /// Tell the consumer that none of the identifiers in `FindIntersect` are known.
    pub struct IntersectNotFound;

    /// Ask the producer to send the next ranking block.
    pub struct RequestNext;

    /// Tell the consumer that they are caught up with the chain, and the next even is going
    /// to arrive when the producer's chain changes.
    pub struct AwaitReply;

    /// Tell the consumer to extend its chain with the next connecting ranking block.
    /// The ranking block is small, it could be the header of a traditional block,
    /// or a dedicated block type.
    pub struct RollForward<E: Era>(E::RankingBlock<'static>);

    /// Tell the consumer to an earlier block hash.
    pub struct RollBackward<E: Era>(RankingBlockHash<E>);

    /// Ask the producer to send a list of missing input block headers.
    /// The consumer should only ask for inputs that they don't have after
    /// being given a new ranking block with `RollForward`. The producer
    /// can work out which input blocks fall in the range between the latest
    /// ranking block it sent the consumer and the one before that, so it
    /// can detect if the consumer is asking for things that are unreasonable.
    pub struct RequestInputs<E: Era>(Vec<InputBlockHash<E>>);

    /// The producer responds to the consumer with the missing inputs block headers.
    /// The response contains the headers for the hashes the consumer asked for in
    /// the preceding `RequestInputs`. Since the producer earlier sent a ranking block
    /// that referenced these, it must have all the inputs as well, so the number of
    /// items must be exactly the same.
    pub struct ReplyInputs<E: Era>(Vec<<E::InputBlock<'static> as HasHeader>::Header>);

    /// Tell the consumer about a new input block header. They can decide if they want to
    /// get the body for it or not. The input blocks are supposed to be generated by PoW,
    /// so accepting random input blocks is not risky, as checking their consistency is
    /// cheap but generating them is expensive, it's not a good mechanism to attack someone.
    ///
    /// At this point it is expected that the producer and consumer already found an intersect
    /// in their chains. The consumer can detect malicious intent like sending old blocks
    /// by checking that the input block sent is not in the past-cone of the shared read pointer,
    /// or for example that the height of the input follows on previous heights.
    pub struct AddInput<E: Era>(InputBlockHeader<E>);

    /// Terminate the protocol.
    pub struct Done;
}

// Protocols described from the server's perspective.
mod protocol {
    use super::messages::*;
    use crate::blockchain::property::Era;
    use crate::session_types::*;

    /// Protocol to find the latest block that intersects in the chains of the client and the server.
    type Intersect<E: Era> = Recv<
        FindIntersect<E>,
        Choose<Send<IntersectFound<E>, Var<Z>>, Send<IntersectNotFound, Var<Z>>>,
    >;

    /// Respond to the consumer with the next available ranking block, or a rollback to an earlier one;
    /// alternatively inform the consumer about an available input block header.
    type Roll<E: Era> = Choose<
        Send<AddInput<E>, Var<Z>>,
        Choose<Send<RollForward<E>, Var<Z>>, Send<RollBackward<E>, Var<Z>>>,
    >;

    /// Protocol to request the next available ranking block or input block header
    type Next<E: Era> = Recv<RequestNext, Choose<Roll<E>, Send<AwaitReply, Roll<E>>>>;

    /// Protocol to request missing input block headers.
    type Missing<E: Era> = Recv<RequestInputs<E>, Send<ReplyInputs<E>, Var<Z>>>;

    /// Receive a quit request to quit from the client.
    type Quit = Recv<Done, Eps>;

    type Server<E: Era> = Offer<Intersect<E>, Offer<Next<E>, Offer<Missing<E>, Quit>>>;

    type Client<E: Era> = <Server<E> as HasDual>::Dual;
}
